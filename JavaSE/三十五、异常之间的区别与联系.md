# **异常之间的区别与联系** 

### **1、Error**

`Error` 类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。

比如说：

 Java虚拟机运行错误（ `Virtual MachineError` ），当JVM不再有继续执行操作所需的内存资源时，

将出现 `OutOfMemoryError` 。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；

还有发生在虚拟机试图执行应用时，如类定义错误（ `NoClassDefFoundError` ）、链接错误

（ `LinkageError` ）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大

多数是程序运行时不允许出现的状况。

对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状

况。在Java中，错误通常是使用 `Error` 的子类描述。

### **2、Exception**

在 `Exception` 分支中有一个重要的子类 `RuntimeException` （运行时异常），该类型的异常自动

为你所编写的程序定义 `ArrayIndexOutOfBoundsException` （数组下标越界）、

`NullPointerException` （空指针异常）、

`ArithmeticException` （算术异常）、 `MissingResourceException` 

（丢失资源）、`ClassNotFoundException` 

（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处

理，也可以不处理。

这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而

`RuntimeException` 之外的异常我们统称为非运行时异常，类型上属于 `Exception` 类及其子类，

从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如

`IOException` 、 `SQLException` 等以及用户自定义的 `Exception` 异常，一般情况下不自定义检

查异常。

注意： `Error` 和 `Exception` 的区别： Error 通常是灾难性的致命的错误，是程序无法控制和

处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程； `Exception` 通常情况下是可

以被程序处理的，并且在程序中应该尽可能的去处理这些异常。

### **3、检查异常和不受检查异常**

检查异常：在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的

发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。

解析：**除了RuntimeException及其子类以外，其他的Exception类及其子类都属于检查异常，**当程序

中可能出现这类异常，**要么使用try-catch语句进行捕获，要么用throws子句抛出，**否则编译无法通

过。

不受检查异常：**包括RuntimeException及其子类和Error。**

分析： `不受检查异常` 为编译器不要求强制处理的异常， `检查异常` 则是编译器要求必须处置的异

常

### Java异常处理机制

java异常处理本质：抛出异常和捕获异常

### 1、抛出异常

异常情形（exception condition），它是指阻止当前方法或作用域

继续执行的问题。其次把异常情形和普通问题相区分，普通问题是指在当前环境下能得到足够的信息，总能处理这个错误。

对于异常情形，已经无法继续下去了，因为在当前环境下无法获得必要的信息来解决问题，你所能做的就是从当前环境中跳出，并把问题提交给上一级环境，这就是抛出异常时所发生的事情。抛出异常后，会有几件事随之发生。

首先，是像创建普通的java对象一样将使用 new 在堆上创建一个异常对象；然后，当前的执行路径

（已经无法继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，

这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。



```java
if(stu == null){ 

throw new NullPointerException(); 

} 
```

### 2、捕获异常

在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（

exception handler）。潜在的异常

处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出

的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

对于 `运行时异常` 、 `错误` 和 `检查异常` ，Java技术所要求的异常处理方式有所不同

由于运行时异常及其子类的不可查性，为了更合理、更容易地实现应用程序，Java规定，**运行时异常将**

**由Java运行时系统自动抛出，允许应用程序忽略运行时异常。**

对于方法运行中可能出现的 `Error` ，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因

为，大多数 `Error` 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。

### **3、异常处理五个关键字**

分别是： `try` 、 `catch` 、 `finally` 、 `throw` 、 `throws`

**try** -- 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常

时，异常就被抛出。

**catch** -- 用于捕获异常。catch用来捕获try语句块中发生的异常。

**finally** -- finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络

连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语

句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。

**throw** -- 用于抛出异常。

**throws** -- 用在方法签名中，用于声明该方法可能抛出的异常。

